library(MASS)

calc_var <- function(X, model, correction = FALSE) {
  # Computes the variance estimation of predictions by X.
  #
  # Args:
  #   X: Covariates of interest
  #   model: Trained random forests model by library randomForest (set keep.inbag = TRUE)
  #   correction: Whether to apply bias correction for diagonal terms (variance)
  #
  # Returns:
  #   A list contains:
  #     y_pred: predictions generated by X using model
  #     var: covariance matrix
  #     zeta1_full: see paper for details
  #     zetan_full: see paper for details
  #   If classification, also returns:
  #     y_prob: probability generated by X using model
  #

  n_train <- length(model$predicted)
  ntree <- model$ntree
  sampsize <- sum(model$inbag[, 1])

  testall <- predict(model, X, predict.all = TRUE)
  y_pred <- testall$aggregate

  if (model$type == "regression") {
    cond_exp_full <- matrix(0, nrow = n_train, ncol = dim(X)[1])

    for (i in 1:n_train) {
      cond_exp_full[i, ] <- rowMeans(testall$individual[, model$inbag[i, ] == 1])
    }

    zeta1_full <- cov(cond_exp_full)
    zetan_full <- cov(t(testall$individual))

    var <- sampsize^2 / n_train * zeta1_full + (1 / ntree) * zetan_full

    if (correction == TRUE) {
      # diag(var) <- diag(var) - diag(cov(t(testall$individual))) * sampsize / ntree * (1 - sampsize / n_train)
      # var <- sampsize^2 / n_train * zeta1_full + (1 / ntree - sampsize / ntree + sampsize^2 / (ntree * n_train)) * zetan_full
      zeta1_full_cor <- n_train * (n_train - 1) / (n_train - sampsize)^2 * (zeta1_full - 1 / ntree * (n_train - sampsize) / n_train * zetan_full)
      var <- sampsize^2 / n_train * zeta1_full_cor + (1 / ntree) * zetan_full

      # in case the bias-corrected version is not positive-definite
      # decomp <- eigen(var)
      # trunc <- decomp$values
      # trunc[trunc < 0] <- 0
      # var <- decomp$vectors %*% diag(trunc) %*% t(decomp$vectors)
    }

    ans <- list("y_pred" = y_pred, "var" = var, "zeta1_full" = zeta1_full, "zetan_full" = zetan_full)

    return(ans)
  }

  if (model$type == "classification") {
    individual <- apply(testall$individual, 2, as.numeric)
    y_prob <- apply(individual, 1, mean)

    cond_exp_full <- matrix(0, nrow = n_train, ncol = dim(X)[1])

    for (i in 1:n_train) {
      cond_exp_full[i, ] <- rowMeans(individual[, model$inbag[i, ] == 1])
    }

    zeta1_full <- cov(cond_exp_full)
    zetan_full <- cov(t(individual))

    var <- sampsize^2 / n_train * zeta1_full + (1 / ntree) * zetan_full

    if (correction == TRUE) {
      # diag(var) <- diag(var) - diag(cov(t(testall$individual))) * sampsize / ntree * (1 - sampsize / n_train)
      # var <- sampsize^2 / n_train * zeta1_full + (1 / ntree - sampsize / ntree + sampsize^2 / (ntree * n_train)) * zetan_full
      zeta1_full_cor <- n_train * (n_train - 1) / (n_train - sampsize)^2 * (zeta1_full - 1 / ntree * (n_train - sampsize) / n_train * zetan_full)
      var <- sampsize^2 / n_train * zeta1_full_cor + (1 / ntree) * zetan_full

      # in case the bias-corrected version is not positive-definite
      # decomp <- eigen(var)
      # trunc <- decomp$values
      # trunc[trunc < 0] <- 0
      # var <- decomp$vectors %*% diag(trunc) %*% t(decomp$vectors)
    }

    ans <- list("y_pred" = y_pred, "y_prob" = y_prob, "var" = var, "zeta1_full" = zeta1_full, "zetan_full" = zetan_full)

    return(ans)
  }
}

ptestu <- function(test, model, correction = TRUE) {
  # Computes p-value for testing whether the means of all points in test are the same.
  #
  # Args:
  #   test: Covariates of test points
  #   model: Trained random forests model by library randomForest (set keep.inbag = TRUE)
  #   correction: Whether to apply bias correction for diagonal terms (variance)
  #
  # Returns:
  #   p-value

  ans <- calc_var(test, model, correction)

  if (model$type == "regression") {
    y_pred <- ans$y_pred
    cov <- ans$var

    n_test <- dim(test)[1]

    df <- n_test

    I <- diag(n_test)
    J <- matrix(1, n_test, n_test)
    subu <- (I - J / n_test) %*% y_pred
    S <- (I - J / n_test) %*% cov %*% (I - J / n_test)

    sta <- t(subu) %*% ginv(S) %*% subu

    return(pchisq(sta, df, lower.tail = FALSE))
  }

  if (model$type == "classification") {
    y_prob <- ans$y_prob
    cov <- ans$var

    n_test <- dim(test)[1]

    df <- n_test

    I <- diag(n_test)
    J <- matrix(1, n_test, n_test)
    subu <- (I - J / n_test) %*% y_prob
    S <- (I - J / n_test) %*% cov %*% (I - J / n_test)

    sta <- t(subu) %*% ginv(S) %*% subu

    return(pchisq(sta, df, lower.tail = FALSE))
  }
}
